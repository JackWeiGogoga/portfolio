{
  "page": {
    "back": "Back to What is it",
    "title": "Java Lock Deep Dive",
    "subtitle": "From object headers to AQS, a full-stack walkthrough for interviews."
  },
  "tabs": [
    {
      "id": "overview",
      "label": "Overview",
      "description": "Map the goal, tradeoffs, and selection strategy for locks."
    },
    {
      "id": "synchronized",
      "label": "synchronized",
      "description": "Object header, lock inflation, bytecode, JVM optimizations."
    },
    {
      "id": "lock",
      "label": "Lock",
      "description": "Explicit locks with interrupt, timeout, and conditions."
    },
    {
      "id": "aqs",
      "label": "AQS",
      "description": "The core: state + CLH queue + park/unpark."
    },
    {
      "id": "interview",
      "label": "Interview",
      "description": "Follow-up questions, pitfalls, and troubleshooting."
    }
  ],
  "overview": {
    "title": "Lock Landscape",
    "intro": "Locks solve three concurrency problems: mutual exclusion, visibility, and ordering. Choosing a lock is a tradeoff between performance and control.",
    "pillars": [
      "Mutual exclusion: limit threads inside the critical section.",
      "Visibility: unlock makes writes visible to the next lock holder.",
      "Ordering: both synchronized and Lock establish happens-before."
    ],
    "highlightsTitle": "Interview Focus",
    "highlights": [
      "Lock inflation path and Mark Word transitions.",
      "When to choose synchronized vs ReentrantLock.",
      "AQS exclusive/shared modes and blocking strategy.",
      "Condition vs wait/notify semantics."
    ],
    "categoriesTitle": "Lock Taxonomy",
    "categories": [
      {
        "title": "Optimistic vs Pessimistic",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "Optimistic",
              "CAS/version; Atomic*, LongAdder, StampedLock optimistic read",
              "Low contention, read-heavy, cheap retries"
            ],
            [
              "Pessimistic",
              "synchronized, ReentrantLock, write lock",
              "High contention or long critical sections"
            ]
          ]
        }
      },
      {
        "title": "Reentrant vs Non-reentrant",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "Reentrant",
              "synchronized (monitor count), ReentrantLock (state++)",
              "Recursion or layered call chains"
            ],
            [
              "Non-reentrant",
              "Custom non-reentrant AQS lock",
              "Prevent accidental reentry"
            ]
          ]
        }
      },
      {
        "title": "Fair vs Non-fair",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "Fair",
              "AQS predecessor check",
              "Predictable latency, lower starvation"
            ],
            [
              "Non-fair",
              "CAS-first barging",
              "Higher throughput for short sections"
            ]
          ]
        }
      },
      {
        "title": "Exclusive vs Shared",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "Exclusive",
              "AQS exclusive: synchronized, ReentrantLock, write lock",
              "Strict mutual exclusion"
            ],
            [
              "Shared",
              "AQS shared: read lock, Semaphore",
              "Read-heavy or permit control"
            ]
          ]
        }
      },
      {
        "title": "No/Biased/Light/Heavy",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "No lock",
              "Mark Word stores hash/age",
              "No contention"
            ],
            [
              "Biased",
              "Store thread id to avoid CAS",
              "Single thread or low contention"
            ],
            [
              "Lightweight",
              "CAS + stack lock record + spinning",
              "Short contention"
            ],
            [
              "Heavyweight",
              "Monitor block/park",
              "High contention or long sections"
            ]
          ]
        }
      },
      {
        "title": "Spin vs Adaptive Spin",
        "table": {
          "headers": [
            "Type",
            "Implementation/Classes",
            "Best Use & Notes"
          ],
          "rows": [
            [
              "Spin",
              "Enabled by default (JDK 6+); -XX:PreBlockSpin tuning",
              "Very short critical sections"
            ],
            [
              "Adaptive spin",
              "Uses history, owner state, CPU load",
              "Avoid wasted spinning"
            ]
          ]
        }
      }
    ],
    "landscapeTitle": "Lock Types",
    "landscape": {
      "headers": [
        "Type",
        "Semantics",
        "Reentrant",
        "Fairness",
        "Typical Use"
      ],
      "rows": [
        [
          "synchronized",
          "JVM monitor",
          "Yes",
          "Non-fair",
          "Basic mutual exclusion"
        ],
        [
          "ReentrantLock",
          "Explicit lock",
          "Yes",
          "Optional fair",
          "Timeout/interrupt/condition"
        ],
        [
          "ReadWriteLock",
          "Read/write split",
          "Yes",
          "Optional fair",
          "Read-heavy workloads"
        ],
        [
          "StampedLock",
          "Optimistic read",
          "No",
          "Non-fair",
          "Read-mostly with retries"
        ]
      ]
    },
    "checklistTitle": "Selection Checklist",
    "checklist": [
      "Need tryLock/timeout/interrupt? Pick ReentrantLock.",
      "Read-heavy with write isolation? Pick ReadWriteLock.",
      "Mostly reads with optimistic validation? Pick StampedLock.",
      "Simple logic without advanced features? synchronized works."
    ]
  },
  "synchronized": {
    "title": "Inside synchronized",
    "summary": "synchronized is a JVM monitor lock backed by Mark Word and Monitor state transitions.",
    "objectHeaderTitle": "Object Header (64-bit + compressed oops)",
    "objectHeaderTable": {
      "headers": [
        "Field",
        "Width",
        "Notes"
      ],
      "rows": [
        [
          "Mark Word",
          "64",
          "hash, age, lock bits, biased thread id"
        ],
        [
          "Klass Pointer",
          "32",
          "points to class metadata"
        ],
        [
          "Padding",
          "32",
          "alignment"
        ],
        [
          "Array Length",
          "32",
          "only for array objects"
        ]
      ]
    },
    "markWordTitle": "Mark Word & Lock States",
    "markWordTable": {
      "headers": [
        "State",
        "Bits",
        "Biased bit",
        "Contents",
        "Trigger"
      ],
      "rows": [
        [
          "No lock",
          "01",
          "0",
          "hash, age",
          "new object"
        ],
        [
          "Biased",
          "01",
          "1",
          "thread id, epoch",
          "single-thread reentry"
        ],
        [
          "Lightweight",
          "00",
          "0",
          "stack lock record",
          "CAS contention"
        ],
        [
          "Heavyweight",
          "10",
          "0",
          "Monitor pointer",
          "spin failed / hot contention"
        ]
      ]
    },
    "upgradeTitle": "Inflation Path",
    "upgradeSteps": [
      "No lock → biased: first thread enters.",
      "Biased → lightweight: another thread CAS fails.",
      "Lightweight → heavyweight: spin fails or contention grows.",
      "Once inflated, it rarely deflates."
    ],
    "upgradeDemo": {
      "title": "Object Header State Changes",
      "note": "Step through the animation to see how Mark Word fields change.",
      "fieldsTitle": "Mark Word Fields",
      "stepsTitle": "Upgrade Steps",
      "arrivingTitle": "Arriving thread",
      "ownerTitle": "Owner",
      "ownerEmpty": "None",
      "waitingTitle": "Waiting/spinning",
      "waitingEmpty": "None",
      "flowTitle": "Thread flow",
      "flowNote": "Threads move from arrival to contention, leading to spinning or blocking and lock inflation.",
      "fields": {
        "lockBits": "Lock bits",
        "biased": "Biased bit",
        "hash": "Hash",
        "age": "Age",
        "threadId": "Thread ID",
        "ptr": "Pointer/record"
      },
      "steps": [
        {
          "id": "no-lock",
          "title": "No lock",
          "description": "New object with hash/age available, lock bits 01.",
          "arrivingThread": "T1",
          "contenders": [],
          "ownerThread": null,
          "lockBits": "01",
          "biased": "0",
          "hash": "0x0000",
          "age": "0010",
          "threadId": "-",
          "ptr": "-"
        },
        {
          "id": "biased",
          "title": "Biased lock",
          "description": "First thread writes ID, biased bit on, still 01.",
          "arrivingThread": "T1",
          "contenders": [],
          "ownerThread": "T1",
          "lockBits": "01",
          "biased": "1",
          "hash": "0x0000",
          "age": "0010",
          "threadId": "T1",
          "ptr": "-"
        },
        {
          "id": "lightweight",
          "title": "Lightweight lock",
          "description": "CAS failure, Mark Word points to stack lock record.",
          "arrivingThread": "T2",
          "contenders": [
            "T2"
          ],
          "ownerThread": "T1",
          "lockBits": "00",
          "biased": "0",
          "hash": "-",
          "age": "0010",
          "threadId": "-",
          "ptr": "LockRecord@T1"
        },
        {
          "id": "heavyweight",
          "title": "Heavyweight lock",
          "description": "Spin failed, inflates to Monitor pointer.",
          "arrivingThread": "T3",
          "contenders": [
            "T2",
            "T3"
          ],
          "ownerThread": "T1",
          "lockBits": "10",
          "biased": "0",
          "hash": "-",
          "age": "0010",
          "threadId": "-",
          "ptr": "Monitor@0x7f"
        }
      ]
    },
    "bytecodeSourceTitle": "Source",
    "bytecodeSource": "public class Counter {\n  private final Object lock = new Object();\n  private int count = 0;\n\n  public void inc() {\n    synchronized (lock) {\n      count++;\n    }\n  }\n}",
    "bytecodeListingTitle": "Bytecode",
    "bytecodeListing": "0: aload_0\n1: getfield #2\n4: dup\n5: astore_1\n6: monitorenter\n7: aload_0\n8: dup\n9: getfield #3\n12: iconst_1\n13: iadd\n14: putfield #3\n17: aload_1\n18: monitorexit\n19: goto 27\n22: astore_2\n23: aload_1\n24: monitorexit\n25: aload_2\n26: athrow\n27: return",
    "scopeTitle": "Where synchronized Applies",
    "scopeTabs": [
      {
        "id": "object",
        "label": "Object lock"
      },
      {
        "id": "class",
        "label": "Class lock"
      }
    ],
    "scopeContent": {
      "object": {
        "summary": "Object locks are tied to instances. The default lock is this, or any explicit object you choose.",
        "examples": [
          {
            "title": "Synchronized method: lock is this",
            "code": "public class InstanceLockDemo implements Runnable {\n  static InstanceLockDemo instance = new InstanceLockDemo();\n\n  @Override\n  public void run() {\n    method();\n  }\n\n  public synchronized void method() {\n    System.out.println(\"Thread \" + Thread.currentThread().getName());\n  }\n\n  public static void main(String[] args) {\n    new Thread(instance).start();\n    new Thread(instance).start();\n  }\n}"
          },
          {
            "title": "Synchronized block: lock this",
            "code": "public class BlockThisDemo implements Runnable {\n  static BlockThisDemo instance = new BlockThisDemo();\n\n  @Override\n  public void run() {\n    synchronized (this) {\n      System.out.println(\"Thread \" + Thread.currentThread().getName());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(instance).start();\n    new Thread(instance).start();\n  }\n}"
          },
          {
            "title": "Synchronized block: custom lock object",
            "code": "public class BlockObjectDemo implements Runnable {\n  static BlockObjectDemo instance = new BlockObjectDemo();\n  private final Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized (lock) {\n      System.out.println(\"Thread \" + Thread.currentThread().getName());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(instance).start();\n    new Thread(instance).start();\n  }\n}"
          }
        ]
      },
      "class": {
        "summary": "Class locks are tied to the Class object. All instances share the same lock.",
        "examples": [
          {
            "title": "Static method: lock is Class",
            "code": "public class ClassLockDemo implements Runnable {\n  static ClassLockDemo instance1 = new ClassLockDemo();\n  static ClassLockDemo instance2 = new ClassLockDemo();\n\n  @Override\n  public void run() {\n    method();\n  }\n\n  public static synchronized void method() {\n    System.out.println(\"Thread \" + Thread.currentThread().getName());\n  }\n\n  public static void main(String[] args) {\n    new Thread(instance1).start();\n    new Thread(instance2).start();\n  }\n}"
          },
          {
            "title": "Synchronized block: lock Class object",
            "code": "public class ClassBlockDemo implements Runnable {\n  static ClassBlockDemo instance1 = new ClassBlockDemo();\n  static ClassBlockDemo instance2 = new ClassBlockDemo();\n\n  @Override\n  public void run() {\n    synchronized (ClassBlockDemo.class) {\n      System.out.println(\"Thread \" + Thread.currentThread().getName());\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(instance1).start();\n    new Thread(instance2).start();\n  }\n}"
          }
        ]
      }
    },
    "optimizationsTitle": "JVM Optimizations",
    "optimizations": [
      "Biased locking for uncontended paths.",
      "Spin before blocking to reduce context switches.",
      "Lock coarsening to merge adjacent locks.",
      "Lock elimination via escape analysis."
    ],
    "optimizationExamplesTitle": "Lock Coarsening & Elimination Examples",
    "optimizationExamples": [
      {
        "title": "Coarsening: merge adjacent locks",
        "summary": "Frequent enter/exit in a loop adds overhead, so JIT may combine them into one larger lock.",
        "code": "public void appendAll(String[] items) {\n  StringBuilder sb = new StringBuilder();\n  for (String item : items) {\n    synchronized (this) {\n      sb.append(item);\n    }\n  }\n  // JIT may coarsen to:\n  // synchronized (this) {\n  //   for (...) sb.append(item);\n  // }\n}"
      },
      {
        "title": "Elimination: object does not escape",
        "summary": "If the lock object is thread-local, JIT can remove the synchronized block entirely.",
        "code": "public String build() {\n  StringBuffer buffer = new StringBuffer();\n  // buffer is only used by this thread\n  buffer.append(\"A\");\n  buffer.append(\"B\");\n  return buffer.toString();\n  // JIT can eliminate internal synchronized\n}"
      }
    ],
    "pitfallsTitle": "Pitfalls",
    "pitfalls": [
      "Locking on mutable references.",
      "String literal locks causing global contention.",
      "I/O inside synchronized blocks.",
      "hashCode can revoke biased locks."
    ]
  },
  "lock": {
    "title": "Lock Family",
    "summary": "Explicit locks add interruption, timeout, fairness, and multiple conditions.",
    "comparisonTitle": "synchronized vs ReentrantLock",
    "comparisonTable": {
      "headers": [
        "Capability",
        "synchronized",
        "ReentrantLock"
      ],
      "rows": [
        [
          "Reentrant",
          "Yes",
          "Yes"
        ],
        [
          "Interrupt",
          "No",
          "lockInterruptibly"
        ],
        [
          "Timeout",
          "No",
          "tryLock(timeout)"
        ],
        [
          "Fairness",
          "Not controllable",
          "Optional fair"
        ],
        [
          "Conditions",
          "wait/notify",
          "Multiple Condition queues"
        ],
        [
          "Diagnostics",
          "Limited",
          "Queue metrics"
        ]
      ]
    },
    "reentrantTitle": "ReentrantLock Example",
    "reentrantCode": "private final ReentrantLock lock = new ReentrantLock(true);\n\npublic int tryUpdate() throws InterruptedException {\n  if (lock.tryLock(200, TimeUnit.MILLISECONDS)) {\n    try {\n      return ++counter;\n    } finally {\n      lock.unlock();\n    }\n  }\n  return -1;\n}",
    "conditionTitle": "Condition Example",
    "conditionCode": "private final ReentrantLock lock = new ReentrantLock();\nprivate final Condition notEmpty = lock.newCondition();\n\npublic int take() throws InterruptedException {\n  lock.lock();\n  try {\n    while (queue.isEmpty()) {\n      notEmpty.await();\n    }\n    return queue.remove();\n  } finally {\n    lock.unlock();\n  }\n}\n\npublic void put(int item) {\n  lock.lock();\n  try {\n    queue.add(item);\n    notEmpty.signal();\n  } finally {\n    lock.unlock();\n  }\n}",
    "readWriteTitle": "ReadWriteLock Example",
    "readWriteCode": "private final ReadWriteLock rw = new ReentrantReadWriteLock();\n\npublic String read() {\n  rw.readLock().lock();\n  try {\n    return cache;\n  } finally {\n    rw.readLock().unlock();\n  }\n}\n\npublic void write(String value) {\n  rw.writeLock().lock();\n  try {\n    cache = value;\n  } finally {\n    rw.writeLock().unlock();\n  }\n}",
    "stampedTitle": "StampedLock Optimistic Read",
    "stampedCode": "private final StampedLock stamped = new StampedLock();\n\npublic String optimisticRead() {\n  long stamp = stamped.tryOptimisticRead();\n  String value = data;\n  if (!stamped.validate(stamp)) {\n    stamp = stamped.readLock();\n    try {\n      value = data;\n    } finally {\n      stamped.unlockRead(stamp);\n    }\n  }\n  return value;\n}",
    "bestPracticesTitle": "Best Practices",
    "bestPractices": [
      "Always unlock in a finally block.",
      "Keep lock scope small and avoid nested locks.",
      "Use tryLock for timeout fallback.",
      "Watch for write starvation in read/write locks."
    ]
  },
  "aqs": {
    "title": "AQS Fundamentals",
    "summary": "AQS models synchronization with a volatile state and a CLH queue of waiting threads.",
    "conceptsTitle": "Core Concepts",
    "concepts": [
      "state: 0 means free; >0 means held count.",
      "Exclusive vs shared modes.",
      "CLH queue: FIFO doubly linked list.",
      "LockSupport.park/unpark for blocking.",
      "ConditionObject as a separate queue."
    ],
    "nodeTableTitle": "Node Fields",
    "nodeTable": {
      "headers": [
        "Field",
        "Meaning",
        "Typical"
      ],
      "rows": [
        [
          "waitStatus",
          "node state",
          "SIGNAL, CANCELLED, CONDITION"
        ],
        [
          "prev/next",
          "links",
          "maintain CLH queue"
        ],
        [
          "thread",
          "owner thread",
          "queued thread ref"
        ],
        [
          "nextWaiter",
          "condition link",
          "shared/condition node"
        ]
      ]
    },
    "acquireTitle": "Acquire Pseudocode",
    "acquirePseudo": "if (tryAcquire()) return;\nnode = enqueue(currentThread);\nfor (;;) {\n  if (node.prev == head && tryAcquire()) {\n    setHead(node);\n    return;\n  }\n  if (shouldParkAfterFailedAcquire()) {\n    park();\n  }\n}",
    "releaseTitle": "Release Pseudocode",
    "releasePseudo": "if (tryRelease()) {\n  Node h = head;\n  if (h != null && h.waitStatus == SIGNAL) {\n    unparkSuccessor(h);\n  }\n}",
    "demo": {
      "title": "AQS Step-by-step Demo",
      "note": "Three threads compete for an exclusive lock with CAS, enqueue, and park/unpark.",
      "structureTitle": "Data Structure View",
      "structureTable": {
        "headers": [
          "Component",
          "Role",
          "Key fields"
        ],
        "rows": [
          [
            "AQS core",
            "Holds sync state",
            "volatile state, head, tail"
          ],
          [
            "Node",
            "Queue node",
            "waitStatus, prev/next, thread"
          ],
          [
            "CLH queue",
            "FIFO ordering",
            "head/tail + doubly linked list"
          ],
          [
            "Condition queue",
            "Condition waiting",
            "nextWaiter list"
          ]
        ]
      },
      "stepDetailsTitle": "Step Breakdown",
      "stepDetails": [
        "T1 succeeds in tryAcquire, state=1, becomes owner.",
        "T2 fails CAS, enqueues, sets predecessor to head and parks.",
        "T3 enqueues at tail waiting for signal.",
        "T1 release succeeds, unparks head.next (T2).",
        "T2 retries tryAcquire, becomes owner.",
        "T2 release unparks T3, queue drains."
      ],
      "lockStateTitle": "Lock State",
      "stateLabel": "state",
      "ownerLabel": "owner",
      "ownerEmpty": "none",
      "queueTitle": "Sync Queue",
      "queueEmpty": "queue is empty",
      "arrivingTitle": "Arriving Thread",
      "stepsTitle": "Steps",
      "headTag": "head",
      "tailTag": "tail",
      "parkedTag": "parked",
      "signalTitle": "Signal",
      "steps": {
        "t1Acquire": {
          "title": "T1 CAS acquires",
          "description": "state 0->1, T1 becomes owner"
        },
        "t2Enqueue": {
          "title": "T2 enqueue",
          "description": "CAS fails, enter CLH queue and park"
        },
        "t3Enqueue": {
          "title": "T3 enqueue",
          "description": "queued behind T2 waiting signal"
        },
        "t1Release": {
          "title": "T1 releases",
          "description": "release succeeds, unpark head",
          "signal": "unpark(T2)"
        },
        "t2Release": {
          "title": "T2 acquires",
          "description": "T2 becomes owner and releases",
          "signal": "unpark(T3)"
        },
        "t3Release": {
          "title": "T3 completes",
          "description": "queue empty, state back to 0"
        }
      }
    },
    "implementations": {
      "title": "AQS in Different Lock Types",
      "demo": {
        "fieldsTitle": "State fields",
        "queueTitle": "Wait queue",
        "queueEmpty": "No waiters",
        "stepsTitle": "Demo steps"
      },
      "reentrantDemo": {
        "title": "ReentrantLock Core Flow (AQS View)",
        "note": "Left shows CLH doubly-linked queue + Node fields, right highlights source lines.",
        "codeTitle": "JDK8 ReentrantLock / AQS Core Source",
        "stateLabel": "state",
        "ownerLabel": "owner",
        "queueTitle": "CLH Doubly-linked Queue",
        "nodeFieldsTitle": "Node fields",
        "stepsTitle": "Steps",
        "headTag": "head",
        "tailTag": "tail",
        "fields": {
          "waitStatus": "waitStatus",
          "prev": "prev",
          "next": "next",
          "thread": "thread",
          "nextWaiter": "nextWaiter"
        },
        "tabs": [
          {
            "id": "nonfair",
            "label": "Non-fair fast path"
          },
          {
            "id": "fair",
            "label": "Fair queued path"
          },
          {
            "id": "queue",
            "label": "Contention + queue"
          },
          {
            "id": "reenter",
            "label": "Reentrant path"
          }
        ],
        "content": {
          "nonfair": {
            "codeTooltips": {
              "9": "compareAndSetState -> unsafe.compareAndSwapInt\nEquivalent:\nif (state == var1) { state = var2; return true; } else { return false; }\nDifferences:\n- CPU-level atomic instruction\n- not interrupted by thread switches\n- no lock needed"
            },
            "codeLines": [
              "ReentrantLock lock = new ReentrantLock(false);",
              "lock.lock();",
              "try {",
              "    System.out.println(\"do something safely\");",
              "} finally {",
              "    lock.unlock();",
              "}",
              "",
              "final void lock() {",
              "    if (compareAndSetState(0, 1)) {",
              "        setExclusiveOwnerThread(Thread.currentThread());",
              "    } else {",
              "        acquire(1);",
              "    }",
              "}",
              "",
              "protected final boolean tryRelease(int releases) {",
              "    int c = getState() - releases;",
              "    if (c == 0) setExclusiveOwnerThread(null);",
              "    setState(c);",
              "    return c == 0;",
              "}"
            ],
            "steps": [
              {
                "id": "t1-call-lock",
                "title": "Call lock()",
                "description": "Enter non-fair lock().",
                "codeLineIndex": 1,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-enter-lock",
                "title": "Enter lock()",
                "description": "Prepare to CAS acquire.",
                "codeLineIndex": 8,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-cas",
                "title": "CAS succeeds",
                "description": "compareAndSetState(0,1) succeeds.",
                "codeLineIndex": 9,
                "state": "1",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-owner",
                "title": "Set owner",
                "description": "exclusiveOwnerThread = T1.",
                "codeLineIndex": 10,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-do",
                "title": "Critical section",
                "description": "Business logic runs.",
                "codeLineIndex": 3,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-unlock",
                "title": "Enter finally",
                "description": "Call unlock().",
                "codeLineIndex": 5,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-tryrelease",
                "title": "Enter tryRelease",
                "description": "Start releasing.",
                "codeLineIndex": 16,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-release-c",
                "title": "Compute new state",
                "description": "c = state - releases.",
                "codeLineIndex": 17,
                "state": "0",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-clear-owner",
                "title": "Clear owner",
                "description": "state reaches 0, owner cleared.",
                "codeLineIndex": 18,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-setstate",
                "title": "Write state",
                "description": "setState(c).",
                "codeLineIndex": 19,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-release-done",
                "title": "Release done",
                "description": "return c == 0.",
                "codeLineIndex": 20,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              }
            ]
          },
          "fair": {
            "codeTooltips": {
              "22": "hasQueuedPredecessors checks if there are queued threads ahead to prevent barging.",
              "23": "compareAndSetState uses CAS to atomically update state."
            },
            "codeLines": [
              "ReentrantLock lock = new ReentrantLock(true);",
              "lock.lock();",
              "try {",
              "    doWork();",
              "} finally {",
              "    lock.unlock();",
              "}",
              "",
              "final void lock() {",
              "    acquire(1);",
              "}",
              "",
              "public final void acquire(int arg) {",
              "    if (!tryAcquire(arg) &&",
              "        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))",
              "        selfInterrupt();",
              "}",
              "",
              "protected final boolean tryAcquire(int acquires) {",
              "    Thread current = Thread.currentThread();",
              "    int c = getState();",
              "    if (c == 0) {",
              "        if (!hasQueuedPredecessors() &&",
              "            compareAndSetState(0, acquires)) {",
              "            setExclusiveOwnerThread(current);",
              "            return true;",
              "        }",
              "    } else if (current == getExclusiveOwnerThread()) {",
              "        int next = c + acquires;",
              "        setState(next);",
              "        return true;",
              "    }",
              "    return false;",
              "}",
              "",
              "private Node addWaiter(Node mode) {",
              "    Node node = new Node(Thread.currentThread(), mode);",
              "    Node pred = tail;",
              "    if (pred != null) {",
              "        node.prev = pred;",
              "        if (compareAndSetTail(pred, node)) {",
              "            pred.next = node;",
              "            return node;",
              "        }",
              "    }",
              "    enq(node);",
              "    return node;",
              "}"
            ],
            "steps": [
              {
                "id": "t1-call-lock",
                "title": "Call lock()",
                "description": "Create a fair lock and enter lock().",
                "codeLineIndex": 1,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-enter-lock",
                "title": "Enter lock()",
                "description": "Fair lock goes directly to acquire(1).",
                "codeLineIndex": 8,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-acquire",
                "title": "Enter acquire",
                "description": "Prepare to tryAcquire.",
                "codeLineIndex": 12,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-tryacquire",
                "title": "Enter tryAcquire",
                "description": "No lock held, check queue predecessors.",
                "codeLineIndex": 18,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-check-queue",
                "title": "No predecessors",
                "description": "hasQueuedPredecessors returns false.",
                "codeLineIndex": 22,
                "state": "0",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-cas",
                "title": "CAS succeeds",
                "description": "compareAndSetState succeeds.",
                "codeLineIndex": 23,
                "state": "1",
                "owner": "-",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-owner",
                "title": "Set owner",
                "description": "exclusiveOwnerThread = T1.",
                "codeLineIndex": 24,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t2-arrive",
                "title": "T2 enters acquire",
                "description": "Lock held, enter wait flow.",
                "codeLineIndex": 12,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t2-fail",
                "title": "tryAcquire returns false",
                "description": "Non-reentrant, acquire fails.",
                "codeLineIndex": 32,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t2-addwaiter",
                "title": "T2 enqueues",
                "description": "addWaiter appends to tail.",
                "codeLineIndex": 35,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t1-unlock",
                "title": "T1 releases",
                "description": "state goes to 0, queue remains.",
                "codeLineIndex": 5,
                "state": "0",
                "owner": "-",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t3-try",
                "title": "T3 tries to barge",
                "description": "state=0 but queue is not empty.",
                "codeLineIndex": 18,
                "state": "0",
                "owner": "-",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t3-queue-check",
                "title": "Predecessor blocks barging",
                "description": "hasQueuedPredecessors is true.",
                "codeLineIndex": 22,
                "state": "0",
                "owner": "-",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t3-addwaiter",
                "title": "T3 enqueues",
                "description": "addWaiter appends to tail.",
                "codeLineIndex": 35,
                "state": "0",
                "owner": "-",
                "headId": "H",
                "tailId": "N3",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "N3",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  },
                  {
                    "id": "N3",
                    "waitStatus": "0",
                    "prev": "N2",
                    "next": "-",
                    "thread": "T3",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t2-acquire",
                "title": "T2 acquires in order",
                "description": "Head waiter acquires, no barging.",
                "codeLineIndex": 23,
                "state": "1",
                "owner": "T2",
                "headId": "N2",
                "tailId": "N3",
                "nodes": [
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N3",
                    "thread": "-",
                    "nextWaiter": "EXCLUSIVE"
                  },
                  {
                    "id": "N3",
                    "waitStatus": "0",
                    "prev": "N2",
                    "next": "-",
                    "thread": "T3",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              }
            ]
          },
          "queue": {
            "codeTooltips": {
              "18": "compareAndSetState uses CAS to update state atomically.",
              "36": "compareAndSetTail uses CAS to append safely."
            },
            "codeLines": [
              "final void lock() {",
              "    if (compareAndSetState(0, 1)) {",
              "        setExclusiveOwnerThread(Thread.currentThread());",
              "    } else {",
              "        acquire(1);",
              "    }",
              "}",
              "",
              "public final void acquire(int arg) {",
              "    if (!tryAcquire(arg) &&",
              "        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))",
              "        selfInterrupt();",
              "}",
              "",
              "final boolean tryAcquire(int arg) {",
              "    Thread current = Thread.currentThread();",
              "    int c = getState();",
              "    if (c == 0) {",
              "        if (compareAndSetState(0, arg)) {",
              "            setExclusiveOwnerThread(current);",
              "            return true;",
              "        }",
              "    } else if (current == getExclusiveOwnerThread()) {",
              "        int next = c + arg;",
              "        if (next < 0) throw new Error(\"Maximum lock count exceeded\");",
              "        setState(next);",
              "        return true;",
              "    }",
              "    return false;",
              "}",
              "",
              "private Node addWaiter(Node mode) {",
              "    Node node = new Node(Thread.currentThread(), mode);",
              "    Node pred = tail;",
              "    if (pred != null) {",
              "        node.prev = pred;",
              "        if (compareAndSetTail(pred, node)) {",
              "            pred.next = node;",
              "            return node;",
              "        }",
              "    }",
              "    enq(node);",
              "    return node;",
              "}",
              "",
              "private Node enq(Node node) {",
              "    for (;;) {",
              "        Node t = tail;",
              "        if (t == null) {",
              "            if (compareAndSetHead(new Node())) {",
              "                tail = head;",
              "            }",
              "        } else {",
              "            node.prev = t;",
              "            if (compareAndSetTail(t, node)) {",
              "                t.next = node;",
              "                return t;",
              "            }",
              "        }",
              "    }",
              "}",
              "",
              "final boolean acquireQueued(Node node, int arg) {",
              "    for (;;) {",
              "        Node p = node.predecessor();",
              "        if (p == head && tryAcquire(arg)) {",
              "            setHead(node);",
              "            p.next = null;",
              "            return false;",
              "        }",
              "        if (shouldParkAfterFailedAcquire(p, node) &&",
              "            parkAndCheckInterrupt()) {",
              "            return true;",
              "        }",
              "    }",
              "}",
              "",
              "protected final boolean tryRelease(int releases) {",
              "    int c = getState() - releases;",
              "    if (c == 0) setExclusiveOwnerThread(null);",
              "    setState(c);",
              "    return c == 0;",
              "}"
            ],
            "steps": [
              {
                "id": "t1-lock",
                "title": "T1 acquires",
                "description": "CAS succeeds, state=1, owner=T1.",
                "codeLineIndex": 1,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t2-acquire",
                "title": "T2 enters acquire",
                "description": "CAS fails, acquire(arg).",
                "codeLineIndex": 9,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "tryAcquire-enter",
                "title": "Enter tryAcquire",
                "description": "Check if lock can be acquired.",
                "codeLineIndex": 14,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "tryAcquire-current",
                "title": "Read current",
                "description": "current = Thread.currentThread().",
                "codeLineIndex": 15,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "tryAcquire-state",
                "title": "Read state",
                "description": "c = getState().",
                "codeLineIndex": 16,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "tryAcquire-return",
                "title": "Return false",
                "description": "Not reentrant, cannot acquire.",
                "codeLineIndex": 28,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "addwaiter-enter",
                "title": "Enter addWaiter",
                "description": "Create and enqueue node.",
                "codeLineIndex": 31,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "addwaiter-new",
                "title": "Create Node",
                "description": "node = new Node(T2, EXCLUSIVE).",
                "codeLineIndex": 32,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "addwaiter-pred",
                "title": "Read tail",
                "description": "pred = tail.",
                "codeLineIndex": 33,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "enq-enter",
                "title": "Enter enq",
                "description": "pred is null, use enq(node).",
                "codeLineIndex": 45,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "enq-tail-null",
                "title": "tail is null",
                "description": "Create head and set tail=head.",
                "codeLineIndex": 49,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "H",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "-",
                    "thread": "-",
                    "nextWaiter": "-"
                  }
                ]
              },
              {
                "id": "enq-link",
                "title": "Link at tail",
                "description": "node.prev=tail, CAS tail, tail.next=node.",
                "codeLineIndex": 54,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "acquireQueued-enter",
                "title": "Enter acquireQueued",
                "description": "Start spinning to acquire.",
                "codeLineIndex": 62,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "acquireQueued-pre",
                "title": "Get predecessor",
                "description": "p = node.predecessor().",
                "codeLineIndex": 64,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "acquireQueued-park",
                "title": "Try park",
                "description": "head.waitStatus=SIGNAL, T2 parks.",
                "codeLineIndex": 70,
                "state": "1",
                "owner": "T1",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "-1",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t1-unlock",
                "title": "T1 releases",
                "description": "tryRelease sets state=0, owner cleared.",
                "codeLineIndex": 77,
                "state": "0",
                "owner": "-",
                "headId": "H",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "H",
                    "waitStatus": "-1",
                    "prev": "-",
                    "next": "N2",
                    "thread": "-",
                    "nextWaiter": "-"
                  },
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "H",
                    "next": "-",
                    "thread": "T2",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t2-acquire",
                "title": "T2 acquires",
                "description": "p==head and tryAcquire succeeds, setHead(node).",
                "codeLineIndex": 66,
                "state": "1",
                "owner": "T2",
                "headId": "N2",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "-",
                    "thread": "-",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t2-sethead",
                "title": "Detach old head",
                "description": "p.next = null.",
                "codeLineIndex": 67,
                "state": "1",
                "owner": "T2",
                "headId": "N2",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "-",
                    "thread": "-",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              },
              {
                "id": "t2-return",
                "title": "Exit acquireQueued",
                "description": "return false.",
                "codeLineIndex": 68,
                "state": "1",
                "owner": "T2",
                "headId": "N2",
                "tailId": "N2",
                "nodes": [
                  {
                    "id": "N2",
                    "waitStatus": "0",
                    "prev": "-",
                    "next": "-",
                    "thread": "-",
                    "nextWaiter": "EXCLUSIVE"
                  }
                ]
              }
            ]
          },
          "reenter": {
            "codeTooltips": {
              "4": "compareAndSetState is an atomic CAS update."
            },
            "codeLines": [
              "final boolean tryAcquire(int arg) {",
              "    Thread current = Thread.currentThread();",
              "    int c = getState();",
              "    if (c == 0) {",
              "        if (compareAndSetState(0, arg)) {",
              "            setExclusiveOwnerThread(current);",
              "            return true;",
              "        }",
              "    } else if (current == getExclusiveOwnerThread()) {",
              "        int next = c + arg;",
              "        if (next < 0) throw new Error(\"Maximum lock count exceeded\");",
              "        setState(next);",
              "        return true;",
              "    }",
              "    return false;",
              "}"
            ],
            "steps": [
              {
                "id": "t1-enter",
                "title": "Enter tryAcquire",
                "description": "Check reentrancy.",
                "codeLineIndex": 0,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-current",
                "title": "Read current",
                "description": "current = Thread.currentThread().",
                "codeLineIndex": 1,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-getstate",
                "title": "Read state",
                "description": "c = getState().",
                "codeLineIndex": 2,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-branch",
                "title": "Reenter branch",
                "description": "current==owner.",
                "codeLineIndex": 8,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-next",
                "title": "Compute next",
                "description": "next = c + arg.",
                "codeLineIndex": 9,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-check",
                "title": "Overflow check",
                "description": "next < 0 throws.",
                "codeLineIndex": 10,
                "state": "1",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-setstate",
                "title": "Update state",
                "description": "setState(next).",
                "codeLineIndex": 11,
                "state": "2",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              },
              {
                "id": "t1-return",
                "title": "Return true",
                "description": "return true.",
                "codeLineIndex": 12,
                "state": "2",
                "owner": "T1",
                "headId": null,
                "tailId": null,
                "nodes": []
              }
            ]
          }
        }
      },
      "tabs": [
        {
          "id": "reentrant",
          "label": "ReentrantLock"
        },
        {
          "id": "readwrite",
          "label": "ReentrantReadWriteLock"
        },
        {
          "id": "semaphore",
          "label": "Semaphore"
        }
      ],
      "content": {
        "reentrant": {
          "summary": "Exclusive lock uses AQS state as hold count; fairness depends on acquire strategy.",
          "features": [
            "state tracks hold count; reentry increments state.",
            "Non-fair tries CAS first; fair checks predecessors.",
            "ConditionObject maintains separate wait queues."
          ],
          "codeTitle": "Core flow",
          "code": "public void lock() {\n  if (!tryAcquire(1)) {\n    acquire(1); // enqueue + park\n  }\n}\n\nprotected boolean tryAcquire(int acquires) {\n  Thread current = Thread.currentThread();\n  int c = getState();\n  if (c == 0) {\n    if (compareAndSetState(0, acquires)) {\n      setExclusiveOwnerThread(current);\n      return true;\n    }\n  } else if (current == getExclusiveOwnerThread()) {\n    setState(c + acquires); // reentrant\n    return true;\n  }\n  return false;\n}",
          "demo": {
            "title": "ReentrantLock Demo",
            "note": "Focus on reentry count and wait queue changes.",
            "structureTitle": "Key structures",
            "structure": [
              "state tracks hold count",
              "exclusiveOwnerThread marks owner",
              "CLH queue holds waiters",
              "ConditionObject keeps condition queue"
            ],
            "usageTitle": "Usage",
            "usage": [
              "lock/tryLock to acquire",
              "unlock releases and signals successor",
              "newCondition creates a wait queue"
            ],
            "steps": [
              {
                "id": "t1-acquire",
                "title": "T1 acquires",
                "description": "state=1, T1 is owner.",
                "queue": [],
                "fields": [
                  {
                    "label": "state",
                    "value": "1"
                  },
                  {
                    "label": "owner",
                    "value": "T1"
                  }
                ]
              },
              {
                "id": "t1-reenter",
                "title": "T1 reenters",
                "description": "reentry increments state to 2.",
                "queue": [],
                "fields": [
                  {
                    "label": "state",
                    "value": "2"
                  },
                  {
                    "label": "owner",
                    "value": "T1"
                  }
                ]
              },
              {
                "id": "t2-queue",
                "title": "T2 enqueues",
                "description": "T2 fails CAS and waits.",
                "queue": [
                  "T2"
                ],
                "fields": [
                  {
                    "label": "state",
                    "value": "2"
                  },
                  {
                    "label": "owner",
                    "value": "T1"
                  }
                ]
              },
              {
                "id": "t1-release",
                "title": "T1 releases",
                "description": "state goes to 0, T2 can acquire.",
                "queue": [],
                "fields": [
                  {
                    "label": "state",
                    "value": "0"
                  },
                  {
                    "label": "owner",
                    "value": "-"
                  }
                ]
              }
            ]
          }
        },
        "readwrite": {
          "summary": "Read/write lock splits state into high 16 bits (read) + low 16 bits (write).",
          "features": [
            "Read lock uses acquireShared/releaseShared.",
            "Write lock uses acquire/release.",
            "Supports read/write exclusion and write preference."
          ],
          "codeTitle": "State split",
          "code": "static int sharedCount(int c) { return c >>> 16; }\nstatic int exclusiveCount(int c) { return c & 0xFFFF; }\n\nprotected int tryAcquireShared(int unused) {\n  for (;;) {\n    int c = getState();\n    if (exclusiveCount(c) != 0 &&\n        getExclusiveOwnerThread() != Thread.currentThread()) {\n      return -1;\n    }\n    if (compareAndSetState(c, c + (1 << 16))) {\n      return 1;\n    }\n  }\n}",
          "demo": {
            "title": "Read/Write Lock Demo",
            "note": "Readers share, writer is exclusive.",
            "structureTitle": "Key structures",
            "structure": [
              "high 16 bits are read count",
              "low 16 bits are write count",
              "read uses shared mode, write uses exclusive"
            ],
            "usageTitle": "Usage",
            "usage": [
              "readLock().lock() for shared reads",
              "writeLock().lock() for exclusive writes",
              "writer waits for readers to drain"
            ],
            "steps": [
              {
                "id": "r1",
                "title": "R1 reads",
                "description": "readCount=1.",
                "queue": [],
                "fields": [
                  {
                    "label": "readCount",
                    "value": "1"
                  },
                  {
                    "label": "writeCount",
                    "value": "0"
                  }
                ]
              },
              {
                "id": "r2",
                "title": "R2 reads",
                "description": "readCount=2.",
                "queue": [],
                "fields": [
                  {
                    "label": "readCount",
                    "value": "2"
                  },
                  {
                    "label": "writeCount",
                    "value": "0"
                  }
                ]
              },
              {
                "id": "w1-queue",
                "title": "W1 waits",
                "description": "writer enqueues while readers hold.",
                "queue": [
                  "W1"
                ],
                "fields": [
                  {
                    "label": "readCount",
                    "value": "2"
                  },
                  {
                    "label": "writeCount",
                    "value": "0"
                  }
                ]
              },
              {
                "id": "w1-acquire",
                "title": "W1 writes",
                "description": "reads drain, writeCount=1.",
                "queue": [],
                "fields": [
                  {
                    "label": "readCount",
                    "value": "0"
                  },
                  {
                    "label": "writeCount",
                    "value": "1"
                  }
                ]
              }
            ]
          }
        },
        "semaphore": {
          "summary": "Semaphore uses state as permits, acquisition/release run in shared mode.",
          "features": [
            "acquireShared CAS-decrements permits.",
            "releaseShared CAS-increments and wakes waiters.",
            "Good for rate limiting and resource pools."
          ],
          "codeTitle": "Shared mode",
          "code": "protected int tryAcquireShared(int acquires) {\n  for (;;) {\n    int available = getState();\n    int remaining = available - acquires;\n    if (remaining < 0) return -1;\n    if (compareAndSetState(available, remaining)) {\n      return 1;\n    }\n  }\n}\n\nprotected boolean tryReleaseShared(int releases) {\n  for (;;) {\n    int current = getState();\n    int next = current + releases;\n    if (compareAndSetState(current, next)) {\n      return true;\n    }\n  }\n}",
          "demo": {
            "title": "Semaphore Demo",
            "note": "State holds permits; waiters queue when permits run out.",
            "structureTitle": "Key structures",
            "structure": [
              "state tracks remaining permits",
              "CLH queue holds waiters",
              "shared mode can wake multiple threads"
            ],
            "usageTitle": "Usage",
            "usage": [
              "acquire(n) to take permits",
              "release(n) to return permits",
              "fair semaphore respects queue order"
            ],
            "steps": [
              {
                "id": "s1",
                "title": "Initial permits",
                "description": "state=2, two threads can pass.",
                "queue": [],
                "fields": [
                  {
                    "label": "permits",
                    "value": "2"
                  }
                ]
              },
              {
                "id": "t1",
                "title": "T1 acquires",
                "description": "state=1.",
                "queue": [],
                "fields": [
                  {
                    "label": "permits",
                    "value": "1"
                  }
                ]
              },
              {
                "id": "t2",
                "title": "T2 acquires",
                "description": "state=0.",
                "queue": [],
                "fields": [
                  {
                    "label": "permits",
                    "value": "0"
                  }
                ]
              },
              {
                "id": "t3-queue",
                "title": "T3 waits",
                "description": "no permits, enqueue.",
                "queue": [
                  "T3"
                ],
                "fields": [
                  {
                    "label": "permits",
                    "value": "0"
                  }
                ]
              }
            ]
          }
        }
      }
    }
  },
  "interview": {
    "title": "Interview Deep Dive",
    "sections": [
      {
        "title": "Must-cover",
        "items": [
          "Lock inflation and object header transitions.",
          "Fair vs non-fair ReentrantLock.",
          "Head/tail responsibilities in AQS.",
          "Condition vs wait/notify."
        ]
      },
      {
        "title": "Troubleshooting",
        "items": [
          "Diagnose contention with jstack/JFR.",
          "Deadlock detection and thread dump reading.",
          "Spin vs block performance tradeoff.",
          "Why lock coarsening can be faster."
        ]
      }
    ],
    "questionsTitle": "Common Follow-ups",
    "questions": [
      {
        "question": "Why is synchronized reentrant?",
        "answer": "The monitor tracks the owning thread and reentry count."
      },
      {
        "question": "Why does AQS need a CLH queue?",
        "answer": "It preserves FIFO order and lets threads block safely."
      },
      {
        "question": "Condition vs wait/notify?",
        "answer": "Condition supports multiple queues bound to explicit locks."
      },
      {
        "question": "Why is StampedLock not reentrant?",
        "answer": "It prioritizes low-overhead stamps over owner tracking."
      }
    ],
    "checklistTitle": "Answer Checklist",
    "checklist": [
      "Explain inflation triggers and irreversibility.",
      "Contrast interrupt, timeout, fairness, conditions.",
      "Cover state, queue, park/unpark in AQS.",
      "Tie lock choice back to real-world scenarios."
    ]
  },
  "labels": {
    "controls": {
      "play": "Play",
      "pause": "Pause",
      "step": "Step",
      "back": "Back",
      "reset": "Reset"
    }
  }
}
