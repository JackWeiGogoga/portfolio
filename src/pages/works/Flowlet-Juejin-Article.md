# Flowlet：内容处理与数据管道的可视化流程编排系统（工程技术深度版）

> 面向专业平台的技术向介绍，聚焦：系统架构、执行模型、异步回调、节点能力细节与工程难点。

---

## 1. 为什么要做 Flowlet

在内容处理、数据清洗、异步回调与多服务协作场景里，传统脚本和单体服务通常会遇到：

- **流程不可视、难复用**：逻辑分散在脚本或服务里，改动成本高。
- **异步回调难推进**：请求发出去很容易，回调与流程状态一致性很难维护。
- **跨服务拼接成本高**：API、Kafka、LLM、向量化、存储等能力难以形成一条“工程级可追踪链路”。

Flowlet 的目标是：**把复杂数据流程变成可视化、可执行、可监控、可复用的工程系统**。

---

## 2. 系统架构与执行模型

### 2.1 三层抽象：设计、定义、执行

- **设计层**：前端可视化拖拽（画布 + 节点配置），面向业务与工程共同协作。
- **定义层**：将画布结构序列化为流程定义（节点类型 + 配置 + 输入输出映射）。
- **执行层**：后端执行引擎按节点拓扑推进，输出进入统一上下文。

关键在于 **“视图 ≠ 执行”**。Flowlet 用结构化定义把两者绑定，使流程可序列化、可恢复、可暂停。

### 2.2 统一执行上下文

执行过程中的数据进入统一上下文：

- `input`：流程输入
- `nodes`：历史节点输出
- `var`：流程变量
- `context`：执行元信息（executionId、flowId、currentNodeId）

这使得节点之间的数据传递和引用成为“约定式标准”，而非散落的自定义字段。

### 2.3 状态推进与恢复

Flowlet 的核心难点之一是 **状态推进策略**：

- 同步节点：执行完成后立即推进后续节点
- 异步节点：记录回调信息，等待回调后再推进

为了确保流程一致性，状态需要持久化（节点级）并支持暂停/恢复，避免出现“回调到达但流程状态未知”的问题。

---

## 3. 异步回调的工程实现难点

常见编排系统通常只擅长同步流程，但真实业务里经常出现：

- 异步 HTTP 回调
- Kafka 事件触发
- 长耗时任务完成通知

Flowlet 通过**双回调通道**解决：

- **HTTP 回调**：传统业务系统或外部服务
- **Kafka 回调**：高吞吐、事件驱动场景

关键技术点：

- **执行状态持久化**：节点进入“等待回调”态
- **回调关联与幂等**：回调必须能映射到正确的节点实例
- **推进控制**：只在回调成功时推进后续节点

---

## 4. 核心节点深度解析（除开始/结束）

以下节点是实际工程编排的核心，按“解决的问题 + 能力细节 + 使用方法”描述。

### 4.1 API 节点（同步 + 异步）

**解决问题：** 对外部服务发起请求，支持同步返回或异步回调。

**能力细节：**

- 支持同步请求：直接产出输出并推进
- 支持异步模式：流程进入等待态，回调后推进
- 输出字段进入上下文，可被下游节点引用

**使用方法：**

- 配置 URL / Method / Headers / Body
- 选择同步或异步
- 下游节点通过变量表达式引用输出

**工程难点：**

- 同一节点要同时支持同步与异步回调
- 需要输出结构化结果，供后续节点可视化引用

---

### 4.2 Kafka 节点（事件驱动 + 异步）

**解决问题：** 在事件驱动系统中，发送消息并等待异步回调。

**能力细节：**

- 支持消息发送到指定 Topic
- 支持回调消息触发流程推进
- 可与 API 节点混合形成 HTTP + MQ 编排

**使用方法：**

- 配置 Topic、Key、Payload
- Payload 可引用上游节点输出字段
- 回调到达后，流程自动继续

**工程难点：**

- Kafka 回调需要可定位到执行实例
- 需保证消息幂等与状态一致

---

### 4.3 子流程节点（流程复用）

**解决问题：** 复杂流程需要模块化拆分、复用。

**能力细节：**

- 调用另一个已定义流程
- 支持输入映射与输出回传
- 子流程像函数调用一样复用

**使用方法：**

- 选择已有流程作为子流程
- 配置输入映射
- 在父流程中使用子流程输出

**工程难点：**

- 父子流程的上下文隔离与数据映射
- 子流程失败时的传播策略

---

### 4.4 代码节点（Python 执行）

**解决问题：** 可视化节点无法覆盖的复杂逻辑。

**能力细节：**

- 通过外部执行服务运行 Python
- 标准入口：`def run(inputs, context)`
- 支持入参映射、超时、内存限制、网络限制

**使用方法：**

```python
# 示例：从输入中抽取字段并计算

def run(inputs, context):
    user = inputs.get("user", {})
    return {"score": user.get("age", 0) * 2}
```

**工程难点：**

- 执行服务与主引擎解耦
- 需严格控制资源与安全边界

---

### 4.5 LLM 节点（大模型调用）

**解决问题：** 在流程中集成大模型能力（摘要、抽取、分类）。

**能力细节：**

- 支持配置模型参数与提示词模板
- 可引用上游节点输出拼接提示词
- 输出结构化字段可直接进入流程上下文

**使用方法：**

- 配置模型提供方、提示词模板
- 使用变量引用拼装输入
- 下游节点直接引用 LLM 输出字段

**工程难点：**

- 处理输出结构化与稳定性
- 控制大模型响应与流程一致性

---

### 4.6 向量存储节点（写入/检索）

**解决问题：** 将文本/图片向量写入向量库或执行向量检索。

**能力细节：**

- 支持向量写入与搜索
- 可与向量化服务组合形成完整检索链路

**使用方法：**

- 上游完成向量化
- 写入向量库或进行相似检索

---

### 4.7 数据转换节点（渐进式配置）

**解决问题：** 节点间数据结构不一致，需要映射或转换。

**能力细节：**

- 可视化字段映射
- 高级表达式模式（保留灵活性）
- 树形字段选择 + 示例值
- 实时预览输出

**使用方法：**

- 选择上游节点作为源
- 通过字段映射生成新结构
- 输出结构供后续节点引用

**工程难点：**

- 需要把“复杂表达式”降级为“可视化映射”
- 同时兼容低门槛与高扩展

---

### 4.8 JSON 解析器节点

**解决问题：** 上游返回 JSON 字符串，需解析为结构化字段。

**能力细节：**

- 字符串解析为对象
- 输出可直接进入上下文引用

---

### 4.9 变量赋值节点

**解决问题：** 在流程中显式存储或覆盖变量。

**能力细节：**

- 支持变量赋值
- 适合流程中间状态保存

---

### 4.10 Simhash 去重节点

**解决问题：** 文本去重或相似内容检测。

**能力细节：**

- 计算 Simhash
- 支持相似性判断

---

### 4.11 关键词匹配节点

**解决问题：** 文本关键词命中检测。

**能力细节：**

- 输入文本 + 关键词集合
- 输出命中结果

---

### 4.12 备注节点

**解决问题：** 流程可读性与说明性增强。

---

## 5. 典型工程流程示例

**内容处理与向量化管道：**

1. API 节点拉取内容
2. 数据转换节点清洗与结构化
3. LLM 节点抽取摘要/标签
4. 向量化节点生成文本向量
5. 向量存储节点写入向量库
6. Kafka 节点异步通知下游

这条链路同时覆盖了**同步与异步**、**结构化处理**、**AI 推理**与**向量检索**。

---

## 6. 配图建议（请按这些位置截图）

- **图 1**：流程编辑器主界面（画布 + 节点面板 + 配置面板）
- **图 2**：数据转换节点配置界面（映射模式 + 字段树）
- **图 3**：流程执行监控 / 节点状态面板
- **图 4**：节点配置示例（API / Kafka / LLM 任意一个）

---

## 7. 结语

Flowlet 的价值不是“拖拽很酷”，而是**把复杂的数据与内容流程，变成工程级可视化系统**：可复用、可追踪、可扩展、可监控。它特别适合内容处理、RAG、异步回调与数据管道场景。

如果你也在做内容处理或 AI 管道系统，欢迎交流。
